프로그래머스 level2 문제 (JAVA)
===============================
    001. 최댓값과 최솟값
    002. JadenCase 문자열 만들기
    003. 최솟값 만들기
    004. 올바른 괄호
         > split("") 사용 시 시간초과 
         > charAt()으로 요소 살피기
    005. 이진 변환 반복하기
    006. 숫자의 표현
         > 홀수인 약수의 개수와 같다.
    007. 피보나치 수
         > bottom-up
    008. 다음 큰 숫자
         > 처음 숫자의 1의 개수를 세고, 이후 다음 숫자중 1의 개수가 큰 숫자를 찾음
    009. 카펫
    010. 짝지어 제거하기
         > 스택에 담으면서 제거해가며, 최종적으로 스택이 비는지 확인!
    011. 영어 끝말잇기
         > 조건에 맞지 않는 단어가 등장했을 경우 연산을 통해 몇번째 사람인지 반환
         > HashSet 사용. contains로 존재여부 확인 가능.
    012. 구명보트
    013. N개의 최소공배수
         > 최대공약수로 나눠주면서 최소공배수를 구해나감
    014. 예상 대진표
         > (a-1)^(b-1) 해서 String 길이를 구해서 푸는 풀이가 있긴 하지만.. 떠올리기 어려울 거 같음.
    015. 점프와 순간이동
         > 순간이동과 점프를 역순으로 나열해서 순간이동 할 수 있으면 /2, 점프해야하면 -1 연산 진행
    016. 멀리 뛰기
         > 피보나치 수열
    017. H-Index
         > 다른사람 풀이는 간단한게 있는데..
    018. 캐시
         > LRU 
    019. 행렬의 곱셈
         > 3중 반복으로 해결 가능 
    020. 괄호 회전하기
         > 배열을 이어붙이면, 회전을 더 쉽게 구현 가능
    021. 위장
         > 안입는 경우 + 1, 모두 안입는 경우 -1
    022. 튜플 
         > Map 함수 
               - 키 확인 : containsKey() 
               - 삽입 : put()
               - 조회 : get()
         > 전체 조회 : 
               - for(Map.Entry<K,V> entry : map.entrySet())
     023. 기능개발
         > 나누어 떨어지면 소요되는 요일이 바로 나오지만, 그렇지 않으면 +1 일 해주어야함.
     024. n^2 배열 자르기
         > 숫자가 매우 커질 수 있어서 long으로
         > 원래의 index를 다시 계산해서 값을 대입해줌
     025. 프린터
         > LinkedList에서 add와 push가 각각 갖고 있는 공간(?)이 다름
         > 우선순위별로 문서가 몇개 있는지 파악 후 문제에서 요구한대로 하나씩 출력해가며 idx를 확인!
     026. 뉴스 클러스터링
          > 자카드 유사도
     027. 전화번호 목록
          > startswith를 사용하면 더 간단히 구현 가능..
     028. 타겟 넘버
          > dfs
     029. 귤 고르기 
          > values()로 값들의 Collections 얻어 올 수 있음
          > Collections.stream().sorted(Comparator)로 정렬 가능
          >.mapToInt(Integer::intValue).toArray()로 int[] 로 변환
     030. k진수에서 소수 개수 구하기
          > Integer.toString(n, k) 로 n을 k진법 수의 String으로 변환 가능..
          > regex + 
     031. 압축
          > 사전에 없는 단어가 나올 때 까지 index를 늘리고(i), 바로 직전을 사전에 등장한 단어를 추가한다. 만약 마지막 단어가 사전에 이미 존재할 경우 바로 단어 추가 후 answer 반환.
     032. 더 맵게
          > 우선 순위 큐를 활용하여 가장 작은 수가 K 이상이 될 때 까지 반복
          > 중간에 Queue.Poll() 에러가 나오면 K 이상으로 만들 수 없는 경우 -1 리턴
     033. 피로도
          > 내 풀이... factorial 만큼 배열을 섞어서 매 경우 search 하여 최댓값 -> (근데 통과는 됨ㅋㅋㅋ)
          > visited[] 변수 만들어서 순서 섞을 수 있도록!
     034. 오픈채팅방
          > Map 으로 아이디 기억해서 최종 닉네임으로 이력 저장
          > 안쓰는 문자 활용해서 split 여기선 !
     035. 주식가격
          > 문제에서 요구한대로 첫날부터 날짜를 세면서, 가격이 떨어진날 날짜를 반영하도록 구현
          > 배열의 마지막일 경우 현재까지 추가된 날짜로
          > 이전에는 큐 사용하지 않고 index 계산으로 풀었음(이게 더 직관적인거 같기도 하고..)
     036. 주차 요금 계산
          > TreeMap 차번호 정렬
          > Class Car : 주차여부, 주차 시각, 주차 기간 저장
          > 나갈 때 주차 시각 계산해서 주차 기간에 +
          > 나가지 않으면 23:59으로 연산
     037. n진수 게임
          > N진수를 구하는 함수와 index 계산하는 함수를 만들어서 해결
     038. 스킬트리
          > 각 스킬트리에 대해 가능한지 확인
          > 인상적인 풀이 :  Regular Expression으로 스킬을 제외한 문자를 모두 제거하고, 순서가 맞는지 확인하는 풀이
     039. 땅따먹기
          > k와 j가 같지 않을 때의 경우중 최대값들을 저장
     040. 방문 길이
          > 길 자체를 방문한 것으로 취급해야해서 좌표로부터 상, 하, 좌, 후를 하나의 길로 보고 처리
     041. 프렌즈4블록
          > 반복을 충분히 해야함. 최악의 경우 1번 지워질 때마다 한개씩 지워질 수 있는 블록도 생성될 수 있음!
     042. 할인 행사
          > 해쉬맵으로 목표 장바구니와, 실제 구매한 장바구니를 만들어 비교해서(isSignIn) 같다면 경우의 수 추가
          > 장바구니가 10개 미만인 경우 구매만, 10개 초과부터는 맨처음 산 item 제거
     043. 파일명 정렬
          > 파일 클래스 정의 - 이름, head, number, idx를 프로퍼티로 가짐
          > compareTo 메소드 Override : 이름 > 숫자 > idx 정렬
          > 문자열 비교 결과는 String.compareTo()로 가져올 수 있음(default는 오름차순)
          > Constructor : name과 idx 를 매개변수로 받아서 담고,
           name을 head와 number로 분리 -> using regular Expression
     44. 모음사전
          > 사전을 만든 후 해당 index 리턴! 
     45. 게임 맵 최단거리
          > DFS로 안풀려서 BFS로..
          > new int[] {x, y} 로 쌍으로 묶어서 진행!
     46. 2 x n 타일링
          > 피보나치 수열! -> 가로로 덧붙이는 경우  
     47. 2개 이하로 다른 비트
          > Long.toBinaryString() => 이진법 문자열로 나타냄
     48. 다리를 지나는 트럭 
          > 다리를 빈 공간으로 채우고, 1초마다 올라갈 수 있으면 트럭이 올라가고, 빠져나오는 처리를 해주면서 모두 빠져나올 때 까지 반복
     49. 가장 큰 수
          > 우선 순위 큐를 활용하여 정렬
          > 정렬의 우선 순위는 두 수를 이어 붙일 때 앞으로 가야하는 순서
          Comparator<String>  
          @Override
          int compare(String s1, String s2) {};
          compare 함수 재정의 
          > try 문은 "0000" 을 "0"으로 반환하기 위함
          > 숫자가 너무 커서 실패 시 그냥 바로 string 반환
     50. 소수 찾기
          > 주어진 숫자들을 가지고 갯수별로 permutaition 하여 소수 일 경우 Set에 추가(중복처리)
          > dfs(HashSet, String[], StringBuilder, int, boolean[])
            >> HashSet 소수가 담긴 집합
            >> String[], StringBuilder, int, boolean[] 
            dfs로 순열을 만들기 위한 숫자목록, 담긴 숫자, 개수, 방문여부
          > isPrime 소수 판별을 위한 함수
     51. 쿼드 압축 후 개수 세기
          > 각 정사각형에 대해 압축 가능한지 확인하는 check 함수
          > 압축 가능한지 확인 후, 가능하지 않으면 4등분하여 반복
     52. 124 나라의 숫자
          > 3진법으로 숫자를 변환. 단, 사용하는 숫자는 1, 2, 4
     53. 큰 수 만들기
          > 앞에서 부터 다음 숫자와 비교해가며 작다면 제거, 크거나 같다면 continue..
          > stack을 활용하여 훨씬 간단하게 구현가능..
          